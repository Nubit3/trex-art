<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rexy Runner - Full Version</title>
    <style>
        body {
            margin: 0;
            background: #000;
            color: #fff;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
            background: radial-gradient(circle, #1a1a2e 0%, #000000 100%);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            pointer-events: none;
        }
        #score-board { font-size: 20px; font-weight: bold; color: #4ade80; text-shadow: 0 0 5px #4ade80; }
        #lives-display { color: #ff4444; font-size: 20px; margin-top: 5px; }
        
        /* Start Screen & Ban Screen */
        #start-screen, #ban-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            text-align: center;
        }
        #start-screen h1 {
            font-size: 40px; color: #4ade80; text-shadow: 0 0 10px #4ade80; margin-bottom: 10px;
        }
        #start-btn-click {
            background: #4ade80; color: #000; border: none;
            padding: 15px 40px; font-size: 24px; font-weight: bold;
            cursor: pointer; margin-top: 20px;
            box-shadow: 0 0 15px #4ade80;
            text-transform: uppercase;
        }
        #start-btn-click:hover { background: #fff; box-shadow: 0 0 25px #fff; }

        /* Mobile Controls */
        #instructions-mobile {
            position: absolute;
            bottom: 20px; right: 20px;
            display: none; /* Hidden on PC by default */
            z-index: 30;
        }
        #mobile-fire-btn {
            width: 80px; height: 80px;
            background: rgba(255, 0, 0, 0.5);
            border: 2px solid red;
            border-radius: 50%;
            color: white; font-weight: bold;
            touch-action: manipulation;
        }

        /* Mute Button */
        #mute-btn {
            position: absolute; top: 10px; right: 10px;
            background: none; border: 1px solid #555;
            color: #555; padding: 5px 10px; cursor: pointer;
            z-index: 40; font-size: 12px;
        }

        /* Animations */
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="score-board">SCORE: <span id="score-display">0000</span></div>
        <div id="tokens">TOKENS: <span id="token-display">0</span></div>
        <div id="lives-display">‚ù§‚ù§‚ù§</div>
    </div>

    <button id="mute-btn">AUDIO: ON</button>

    <div id="start-screen">
        <h1>REXY RUNNER</h1>
        <p>SCORE: 0<br>TOKENS: 0</p>
        <button id="start-btn-click">START GAME</button>
    </div>

    <div id="ban-screen" style="display:none;">
        <h1 style="color:red;">ACCESS DENIED</h1>
        <p>Security protocol violation detected.</p>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="instructions-mobile">
        <button id="mobile-fire-btn">FIRE</button>
    </div>

    <script>
    (function() {
        // --- üõ°Ô∏è SECURITY CORE ---
        localStorage.removeItem('rexy_ban_status');
        window.godMode = false; window.infiniteAmmo = false;
        let _s = 0; let _t = 0;
        let _lastT = 0; let _lastFire = 0;

        if(localStorage.getItem('rexy_ban_status') === 'banned') {
            document.getElementById('ban-screen').style.display = 'flex';
            document.getElementById('start-screen').style.display = 'none';
            return;
        }

        function checkSecurity() {
            if(window.godMode || window.infiniteAmmo) {
                 document.getElementById('ban-screen').style.display = 'flex';
                 document.getElementById('start-screen').style.display = 'none';
                 gameState = 'BANNED';
                 stopMusic();
            }
        }

        // --- CONFIG ---
        let isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // Toggle Mobile UI
        if (isMobile) {
            const mControls = document.getElementById('instructions-mobile');
            if(mControls) mControls.style.display = 'block';
        }

        const img = (src) => {
            const i = new Image();
            i.src = src;
            i.onerror = () => { console.log("Failed to load: " + src); };
            return i;
        };

        const assets = {
            ship: img("ship.png"),
            inv1: img("invader1.png"),
            inv2: img("invader2.png"),
            inv3: img("invader3.png"),
            boss: img("mothership.png"),
            token: img("rex-token.png")
        };

        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        let W, H;

        // FPS THROTTLE (Strict 60FPS)
        const FPS = 60; const interval = 1000/FPS; let then = Date.now();

        let stars = [], nebulas = [], distantFlashes = [];

        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            if (!isMobile && W > 800) W = 800;
            canvas.width = W;
            canvas.height = H;
            canvas.style.width = W + 'px';
            canvas.style.height = H + 'px';
            ctx.imageSmoothingEnabled = false;
            if(player) player.y = H - 100;
            initSpace();
        }
        window.addEventListener('resize', resize);

        // --- GAME STATE ---
        let gameState = 'MENU';
        let input = { fire: false };

        // Player Object
        const player = { x: 0, y: 0, w: 40, h: 40, speed: 6, cd: 0, lives: 3, invulnTimer: 0 };

        let bullets = [], invaders = [], tokens = [], particles = [], bunkers = [];
        let invaderDir = 1; let invaderSpeed = 1; let wave = 1;

        // --- BOSS LOGIC ---
        let ufo = { x: -300, y: 50, w: 150, h: 75, active: false, dir: 1, speed: 1.5, hp: 10, maxHp: 10 };
        let ufoTimer = 0;
        let nextUfoTime = 900;

        // --- üéµ AUDIO ENGINE ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let isMuted = false;

        // SFX Synthesizer
        const sfx = (type) => {
            if(isMuted || audioCtx.state === 'suspended') return;
            const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
            const now = audioCtx.currentTime; o.connect(g); g.connect(audioCtx.destination);

            if (type === 'shoot') {
                o.type = 'square'; o.frequency.setValueAtTime(800, now); o.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                g.gain.setValueAtTime(0.05, now); g.gain.linearRampToValueAtTime(0, now + 0.15);
                o.start(); o.stop(now + 0.15);
            }
            else if (type === 'explo') {
                o.type = 'sawtooth'; o.frequency.setValueAtTime(150, now); o.frequency.exponentialRampToValueAtTime(10, now + 0.3);
                g.gain.setValueAtTime(0.1, now); g.gain.linearRampToValueAtTime(0, now + 0.3);
                o.start(); o.stop(now + 0.3);
            }
            else if (type === 'coin') {
                o.type = 'sine'; o.frequency.setValueAtTime(1200, now); o.frequency.setValueAtTime(1600, now + 0.1);
                g.gain.setValueAtTime(0.05, now); g.gain.linearRampToValueAtTime(0, now + 0.2);
                o.start(); o.stop(now + 0.2);
            }
            else if (type === 'hit') {
                o.type = 'square'; o.frequency.setValueAtTime(100, now);
                g.gain.setValueAtTime(0.05, now); g.gain.linearRampToValueAtTime(0, now + 0.05);
                o.start(); o.stop(now + 0.05);
            }
            else if (type === 'ufo') {
                o.type = 'triangle'; o.frequency.setValueAtTime(200, now); o.frequency.linearRampToValueAtTime(600, now + 0.5);
                g.gain.setValueAtTime(0.1, now); g.gain.linearRampToValueAtTime(0, now + 0.5);
                o.start(); o.stop(now + 0.5);
            }
        };

        // --- üéπ MUSIC GENERATOR (Dark Synth) ---
        let musicTimer = null;
        let noteIndex = 0;
        const bassLine = [55, 55, 0, 55, 55, 55, 0, 55, 65.41, 65.41, 0, 65.41, 49, 49, 0, 49];

        function startMusic() {
            if (musicTimer) clearInterval(musicTimer);
            noteIndex = 0;
            musicTimer = setInterval(() => {
                if(gameState !== 'PLAY' || isMuted || audioCtx.state === 'suspended') return;
                const freq = bassLine[noteIndex % bassLine.length];
                noteIndex++;
                if(freq > 0) playSynthBass(freq);
            }, 150);
        }

        function stopMusic() {
            if (musicTimer) clearInterval(musicTimer);
            musicTimer = null;
        }

        function playSynthBass(freq) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            osc.type = 'sawtooth';
            osc.frequency.value = freq;
            filter.type = 'lowpass';
            filter.frequency.value = 400;

            const now = audioCtx.currentTime;
            gain.gain.setValueAtTime(0.15, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now);
            osc.stop(now + 0.12);
        }

        function initSpace() {
            stars = []; nebulas = [];
            for(let i=0; i<150; i++) stars.push({ x: Math.random() * W, y: Math.random() * H, size: Math.random() * 2, speed: 0.1 + Math.random() * 1.5, alpha: Math.random() });
            const colors = ['rgba(76, 29, 149, 0.2)', 'rgba(30, 58, 138, 0.2)', 'rgba(219, 39, 119, 0.1)'];
            for(let i=0; i<8; i++) {
                nebulas.push({ x: Math.random() * W, y: Math.random() * H, r: 150 + Math.random() * 250, color: colors[i % 3], vx: (Math.random() - 0.5) * 0.2, vy: (Math.random() - 0.5) * 0.2 });
            }
        }

        function drawGalaxy() {
            ctx.clearRect(0, 0, W, H);
            nebulas.forEach(n => {
                let g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
                g.addColorStop(0, n.color); g.addColorStop(1, 'transparent');
                ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);
                if(gameState === 'PLAY') { n.x += n.vx; n.y += n.vy; if(n.x < -n.r) n.x = W+n.r; if(n.x > W+n.r) n.x = -n.r; if(n.y < -n.r) n.y = H+n.r; if(n.y > H+n.r) n.y = -n.r; }
            });
            if(gameState === 'PLAY' && Math.random() < 0.05) { distantFlashes.push({x: Math.random()*W, y: Math.random()*H/1.5, life: 5 + Math.random()*10, size: 2 + Math.random()*4 }); }
            distantFlashes.forEach((f, i) => {
                 ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#ff5555'; ctx.globalAlpha = f.life / 15;
                 ctx.beginPath(); ctx.arc(f.x, f.y, f.size, 0, Math.PI*2); ctx.fill();
                 f.life--; if(f.life <= 0) distantFlashes.splice(i,1);
            });
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = "#ffffff";
            stars.forEach(s => {
                ctx.globalAlpha = s.alpha * (0.5 + Math.random()*0.5); ctx.fillRect(s.x, s.y, s.size, s.size);
                if(gameState === 'PLAY') s.y += s.speed; if(s.y > H) { s.y = 0; s.x = Math.random() * W; }
            });
            ctx.globalAlpha = 1.0;
        }

        function createExplosion(x, y, color) {
            for(let i=0; i<12; i++) particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, life: 30, color: color });
        }

        function initWave() {
            player.x = W/2 - 20; player.y = H - 100;
            bullets = []; tokens = []; invaders = []; bunkers = [];
            invaderDir = 1;
            
            const baseSpeed = isMobile ? 0.5 : 0.8;
            const speedScale = isMobile ? 0.2 : 0.3;
            invaderSpeed = baseSpeed + (wave * speedScale);

            const cols = Math.min(8, Math.floor((W - 40) / 50));
            const rows = 5;
            const startX = (W - (cols * 50)) / 2;
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    let type = 'inv1'; if(r===0) type = 'inv3'; else if(r===1 || r===2) type = 'inv2';
                    invaders.push({ x: startX + (c * 50), y: 80 + (r * 45), w: 30, h: 30, type: type, state: 'march' });
                }
            }
            const bWidth = 60; const bY = player.y - 100;
            const count = 3;
            const spacing = W / (count + 1);
            const bunkerMap = [[0,1,1,1,1,0], [1,1,1,1,1,1], [1,1,1,1,1,1], [1,1,0,0,1,1]];
            for(let i=1; i<=count; i++) {
                let bx = (spacing * i) - (bWidth/2);
                for(let r=0; r<bunkerMap.length; r++) for(let c=0; c<bunkerMap[r].length; c++) if(bunkerMap[r][c] === 1) bunkers.push({ x: bx + (c*10), y: bY + (r*10), w: 10, h: 10, hp: 1 });
            }
        }

        function update() {
            if(gameState !== 'PLAY') return;

            checkSecurity();
            if (player.invulnTimer > 0) player.invulnTimer--;

            if(player.cd > 0) player.cd--;
            if(input.fire && player.cd === 0) {
                const now = Date.now();
                if (now - _lastFire < 150) { }
                _lastFire = now;
                bullets.push({ x: player.x + player.w/2 - 2, y: player.y, w: 4, h: 12, type: 'p' });
                player.cd = 25;
                sfx('shoot');
            }

            // Boss Logic
            if (!ufo.active) {
                ufoTimer++;
                if (ufoTimer > nextUfoTime) {
                    ufo.active = true; ufo.hp = 10; ufo.dir = Math.random() > 0.5 ? 1 : -1;
                    ufo.y = 50 + Math.random() * 20; ufo.x = ufo.dir === 1 ? -200 : W + 200;
                    ufo.speed = 1.0; ufoTimer = 0; nextUfoTime = 900 + Math.random() * 1500; sfx('ufo');
                }
            } else {
                ufo.x += ufo.speed * ufo.dir;
                if (ufo.x > W + 250 || ufo.x < -250) { ufo.active = false; ufoTimer = 0; }
            }

            // Bullet Logic
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i]; let hit = false;
                if (b.type === 'p') {
                    b.y -= 8;
                    // Hit Boss
                    if (ufo.active && b.x > ufo.x && b.x < ufo.x + ufo.w && b.y > ufo.y && b.y < ufo.y + ufo.h) {
                        createExplosion(b.x, b.y, '#FFAA00'); sfx('hit'); ufo.hp--; bullets.splice(i, 1); hit = true;
                        if (ufo.hp <= 0) { createExplosion(ufo.x + ufo.w/2, ufo.y + ufo.h/2, '#FFD700'); sfx('coin'); _s += 1000; _t += 10; document.getElementById('token-display').innerText = _t; ufo.active = false; }
                    }
                    if (!hit) {
                        // Hit Invaders
                        for (let j = invaders.length - 1; j >= 0; j--) {
                            let inv = invaders[j];
                            if (b.x < inv.x + inv.w && b.x + b.w > inv.x && b.y < inv.y + inv.h && b.y + b.h > inv.y) {
                                createExplosion(inv.x + inv.w/2, inv.y + inv.h/2, '#4ade80'); sfx('explo');
                                if (Math.random() < 0.25) tokens.push({ x: inv.x, y: inv.y });
                                _s += 100; document.getElementById('score-display').innerText = _s; invaders.splice(j, 1); hit = true; break;
                            }
                        }
                    }
                } else {
                    // Enemy Bullet
                    b.y += 5;
                    if (b.x < player.x + player.w - 5 && b.x + b.w > player.x + 5 && b.y < player.y + player.h && b.y + b.h > player.y) { playerHit(); bullets.splice(i, 1); hit = true; }
                    else if (b.y > H) { bullets.splice(i, 1); hit = true; }
                }
                // Hit Bunkers
                if (!hit) for (let k = bunkers.length - 1; k >= 0; k--) {
                    let wall = bunkers[k];
                    if (b.x < wall.x + wall.w && b.x + b.w > wall.x && b.y < wall.y + wall.h && b.y + b.h > wall.y) {
                        createExplosion(wall.x + 5, wall.y + 5, '#C5A000'); sfx('hit'); bunkers.splice(k, 1); hit = true; break;
                    }
                }
                if (hit || b.y < 0) bullets.splice(i, 1);
            }

            let hitEdge = false; let lowestY = 0;
            const diveSpeed = isMobile ? 2.5 : 4; 

            invaders.forEach(inv => {
                if (inv.state === 'dive') { 
                    inv.y += diveSpeed; 
                    if (inv.x < player.x) inv.x += 1; else inv.x -= 1; 
                }
                else { 
                    inv.x += invaderSpeed * invaderDir; 
                    lowestY = Math.max(lowestY, inv.y); 
                    if (inv.x <= 10 || inv.x + inv.w >= W - 10) hitEdge = true; 
                    
                    const diveChance = isMobile ? 0.0003 : 0.0005;
                    if (Math.random() < diveChance) { inv.state = 'dive'; } 
                }
                if (Math.random() < 0.0008 * wave) bullets.push({ x: inv.x + inv.w/2, y: inv.y + inv.h, w: 4, h: 10, type: 'e' });
                if (inv.x < player.x + player.w && inv.x + inv.w > player.x && inv.y < player.y + player.h && inv.y + inv.h > player.y) playerHit();
                if (inv.y > H) inv.y = 0;
            });

            if (hitEdge) { 
                invaderDir *= -1; 
                invaders.forEach(inv => { 
                    const dropDistance = isMobile ? 8 : 15;
                    if(inv.state==='march') inv.y += dropDistance; 
                }); 
            }

            if (invaders.length === 0) { wave++; initWave(); }
            if (lowestY >= player.y - 10) playerHit(true);

            for (let i = tokens.length - 1; i >= 0; i--) {
                let t = tokens[i];
                t.y += 3;
                if (t.x < player.x + player.w && t.x + 20 > player.x && t.y < player.y + player.h && t.y + 20 > player.y) {
                    const now = Date.now(); if (now - _lastT < 50) { } _lastT = now; _t += 1; document.getElementById('token-display').innerText = _t; sfx('coin'); tokens.splice(i, 1);
                } else if (t.y > H) { tokens.splice(i, 1); }
            }
            particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life--; if (p.life <= 0) particles.splice(i, 1); });
        }

        function playerHit(instantKill = false) {
            if (player.invulnTimer > 0) return;
            createExplosion(player.x + player.w/2, player.y + player.h/2, '#ff4444'); sfx('explo');
            if (instantKill) player.lives = 0; else player.lives--;
            let hearts = ""; for(let i=0; i<player.lives; i++) hearts += "‚ù§";
            document.getElementById('lives-display').innerText = hearts;
            if (player.lives <= 0) {
                gameState = 'MENU';
                stopMusic(); 
                document.getElementById('start-screen').style.display = 'flex';
                document.querySelector('#start-screen h1').innerText = "GAME OVER";
                document.querySelector('#start-screen p').innerHTML = "SCORE: " + _s + "<br>TOKENS: " + _t + "<br><br><span style='color:#fff; animation: blink 1s infinite;'>TAP TO RETRY</span>";
            } else { bullets = []; player.x = W/2 - 20; player.invulnTimer = 120; }
        }

        function draw() {
            if(gameState === 'BANNED') return;
            ctx.clearRect(0, 0, W, H);
            drawGalaxy();

            if (player.invulnTimer > 0 && Math.floor(Date.now() / 100) % 2 === 0) { } else {
                if (assets.ship.complete && assets.ship.naturalWidth > 0) { ctx.drawImage(assets.ship, player.x, player.y, player.w, player.h); }
                else { ctx.fillStyle = '#4ade80'; ctx.beginPath(); ctx.moveTo(player.x + 20, player.y); ctx.lineTo(player.x + 40, player.y + 40); ctx.lineTo(player.x, player.y + 40); ctx.fill(); }
            }

            ctx.fillStyle = '#FFD700'; bunkers.forEach(b => { ctx.fillRect(b.x, b.y, b.w, b.h); });

            invaders.forEach(inv => {
                let img = assets[inv.type];
                if (inv.state === 'dive') { ctx.save(); ctx.shadowColor='red'; ctx.shadowBlur=20; }
                if (img.complete && img.naturalWidth > 0) {
                    let bob = Math.sin(Date.now() / 200) * 2;
                    ctx.drawImage(img, inv.x, inv.y + bob, inv.w, inv.h);
                } else {
                    ctx.fillStyle = (inv.state === 'dive') ? 'red' : (inv.type === 'inv3' ? '#ff4444' : '#3b82f6');
                    ctx.fillRect(inv.x, inv.y, inv.w, inv.h);
                }
                if (inv.state === 'dive') ctx.restore();
            });

            if (ufo.active) {
                const barW = 100; const hpW = (ufo.hp / ufo.maxHp) * barW; const barX = ufo.x + (ufo.w - barW)/2;
                ctx.fillStyle = '#330000'; ctx.fillRect(barX, ufo.y - 15, barW, 6); ctx.fillStyle = '#ff0000'; ctx.fillRect(barX, ufo.y - 15, hpW, 6);
                if (assets.boss.complete && assets.boss.naturalWidth > 0) { ctx.save(); ctx.shadowColor = '#FF0000'; ctx.shadowBlur = 20; ctx.drawImage(assets.boss, ufo.x, ufo.y, ufo.w, ufo.h); ctx.restore(); }
                else { ctx.fillStyle = '#ff0000'; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 15; ctx.beginPath(); ctx.ellipse(ufo.x + ufo.w/2, ufo.y + ufo.h/2, ufo.w/2, ufo.h/3, 0, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0; }
            }

            bullets.forEach(b => {
                if (b.type === 'p') { ctx.fillStyle = '#00ff00'; ctx.shadowBlur = 10; ctx.shadowColor = '#00ff00'; ctx.fillRect(b.x, b.y, b.w, b.h); ctx.shadowBlur = 0; }
                else { ctx.fillStyle = '#ff0000'; ctx.shadowBlur = 10; ctx.shadowColor = '#ff0000'; ctx.fillRect(b.x, b.y, b.w, b.h); ctx.shadowBlur = 0; }
            });

            tokens.forEach(t => {
                if (assets.token.complete && assets.token.naturalWidth > 0) { ctx.save(); ctx.shadowBlur = 20; ctx.shadowColor = "#FFD700"; const pulse = 1 + Math.sin(Date.now() / 150) * 0.2; const size = 30 * pulse; const offset = (size - 30) / 2; ctx.drawImage(assets.token, t.x - offset, t.y - offset, size, size); ctx.restore(); } else { ctx.fillStyle = 'gold'; ctx.beginPath(); ctx.arc(t.x + 10, t.y + 10, 8, 0, Math.PI*2); ctx.fill(); }
            });

            particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 30; ctx.fillRect(p.x, p.y, 3, 3); ctx.globalAlpha = 1.0; });
        }

        // --- INPUT HANDLING (FIXED FOR PC) ---
        const handleMove = (e) => {
            if (gameState !== 'PLAY') return;
            let clientX;
            if (e.touches) { clientX = e.touches[0].clientX; } else { clientX = e.clientX; }
            const rect = canvas.getBoundingClientRect();
            const scaleX = W / rect.width;
            let gameInputX = (clientX - rect.left) * scaleX;
            player.x = gameInputX - (player.w / 2);
            player.x = Math.max(10, Math.min(W - player.w - 10, player.x));
        };

        const startFire = () => { input.fire = true; };
        const stopFire = () => { input.fire = false; };

        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mousedown', (e) => { startFire(); });
        canvas.addEventListener('mouseup', stopFire);
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); }, { passive: false });

        // --- üõ†Ô∏è FIX: ADDED SAFETY CHECK FOR MOBILE BUTTON ---
        const fireBtn = document.getElementById('mobile-fire-btn');
        if (fireBtn) {
            fireBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startFire(); }, { passive: false });
            fireBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopFire(); });
        }

        const startBtnClick = document.getElementById('start-btn-click');
        if (startBtnClick) {
            startBtnClick.addEventListener('click', () => {
                 if(gameState === 'BANNED') return;
                 if(audioCtx.state === 'suspended') audioCtx.resume();
                 document.getElementById('start-screen').style.display = 'none';
                 _s = 0; _t = 0; wave = 1; player.lives = 3;
                 document.getElementById('score-display').innerText = '0000';
                 document.getElementById('token-display').innerText = '0';
                 document.getElementById('lives-display').innerText = '‚ù§‚ù§‚ù§';
                 resize(); initWave();
                 gameState = 'PLAY';
                 startMusic(); 
            });
        }

        // --- üõ†Ô∏è FIX: ADDED SAFETY CHECK FOR MUTE BUTTON ---
        const muteBtn = document.getElementById('mute-btn');
        if (muteBtn) {
            muteBtn.addEventListener('click', (e) => { e.stopPropagation(); isMuted = !isMuted; muteBtn.innerText = isMuted ? "AUDIO: OFF" : "AUDIO: ON"; });
        }

        function loop() {
            requestAnimationFrame(loop);
            const now = Date.now(); const elapsed = now - then;
            if (elapsed > interval) { then = now - (elapsed % interval); update(); draw(); }
        }
        resize(); initSpace(); loop();
    })();
    </script>
</body>
</html>
