<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Rexy Invaders: Neon Ops</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    /* --- CORE & ATMOSPHERE --- */
    html, body { 
        margin: 0; padding: 0; width: 100%; height: 100%; 
        overflow: hidden; background-color: #000; 
        font-family: 'Press Start 2P', cursive; 
        user-select: none; -webkit-user-select: none; 
        touch-action: none; /* Prevents scrolling on mobile */
    }

    #game-wrapper {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        overflow: hidden; background: #000;
        display: flex; justify-content: center; align-items: center;
    }

    #game-container {
        position: relative;
        width: 100%; height: 100%;
        background: radial-gradient(circle at center, #1a0b2e 0%, #020205 80%, #000000 100%);
        display: flex; justify-content: center; align-items: center;
    }

    canvas { 
        display: block; 
        box-shadow: 0 0 50px rgba(0,0,0,0.5);
        image-rendering: pixelated; /* Fixes blurry scaling */
    }

    /* CRT SCANLINES */
    #scanlines {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: linear-gradient(to bottom, rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
        background-size: 100% 3px, 3px 100%;
        pointer-events: none; z-index: 5; opacity: 0.4;
    }

    /* --- HUD --- */
    .ui-top {
        position: absolute; top: 10px; width: 100%; max-width: 800px;
        display: flex; justify-content: space-between; padding: 0 10px; box-sizing: border-box;
        z-index: 10; pointer-events: none;
        text-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
    }
    .hud-text { color: #fff; font-size: 12px; letter-spacing: 1px; }
    .hearts { color: #ff4444; font-size: 12px; text-shadow: 0 0 10px #ff4444; }
    .token-glow { color: #FFD700; text-shadow: 0 0 15px #FFD700; }

    /* --- SCREENS --- */
    #start-screen, #ban-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85); backdrop-filter: blur(8px);
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        z-index: 50; text-align: center; cursor: default;
    }
    #ban-screen { border: 20px solid #500000; background: #1a0000; display: none; }

    #mute-btn {
        position: absolute; bottom: 20px; left: 20px; z-index: 30;
        background: rgba(0,0,0,0.5); border: 1px solid #444; color: #888;
        padding: 8px 16px; font-size: 10px; cursor: pointer; border-radius: 20px;
        transition: 0.2s;
    }
    #mute-btn:hover { border-color: #fff; color: #fff; }

    /* --- MOBILE CONTROLS --- */
    #mobile-fire-btn {
        display: none; /* Hidden on PC */
        position: absolute;
        bottom: 30px;
        right: 20px;
        width: 80px;
        height: 80px;
        background: rgba(255, 68, 68, 0.3);
        border: 4px solid #ff4444;
        border-radius: 50%;
        color: white;
        font-family: 'Press Start 2P', cursive;
        font-size: 12px;
        z-index: 40;
        touch-action: none;
        user-select: none;
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
    }
    #mobile-fire-btn:active {
        background: rgba(255, 68, 68, 0.8);
        transform: scale(0.95);
    }

    .start-btn {
        border: 2px solid #fff; padding: 15px 30px; color: #fff;
        font-family: 'Press Start 2P', cursive; cursor: pointer;
        animation: blink 1s infinite; margin-top: 20px;
        pointer-events: auto;
    }
    @keyframes blink { 50% { opacity: 0.5; } }
  </style>
</head>
<body>

<div id="game-wrapper">
    <div id="game-container">
        <div id="scanlines"></div>

        <div class="ui-top">
            <div class="hud-text">HP:<span id="lives-display" class="hearts">‚ù§‚ù§‚ù§</span></div>
            <div class="hud-text">PTS:<span id="score-display">0000</span></div>
            <div class="hud-text token-glow">$REX:<span id="token-display">0</span></div>
        </div>

        <div id="start-screen">
            <h1 style="color: #4ade80; margin-bottom: 30px; font-size: 32px; text-shadow: 0 0 20px #4ade80;">REXY INVADERS</h1>
            <p style="color: #ccc; font-size: 12px; margin-bottom: 50px; line-height: 2; padding: 0 20px;">
                <span id="instructions-desktop">MOUSE TO MOVE ‚Ä¢ CLICK TO FIRE</span>
                <span id="instructions-mobile" style="display:none;">SLIDE TO MOVE ‚Ä¢ TAP BUTTON TO FIRE</span>
                <br><br>
                <span style="color: #FFD700; text-shadow: 0 0 10px #FFD700;">‚ö† SECURE CONNECTION ‚ö†</span>
            </p>
            <div id="start-btn-click" class="start-btn">
                INITIATE LAUNCH
            </div>
        </div>

        <div id="ban-screen">
            <h1 style="font-size: 30px; margin-bottom:20px; color: red; text-shadow: 0 0 20px red;">SYSTEM LOCKDOWN</h1>
            <div style="color: #ffaaaa; margin-bottom: 20px;">SECURITY ALERT: UNAUTHORIZED MANIPULATION</div>
        </div>

        <div id="mute-btn">AUDIO: ON</div>
        
        <button id="mobile-fire-btn">FIRE</button>

        <canvas id="gameCanvas"></canvas>
    </div>
</div>

<script>
(function() {
    // --- üõ°Ô∏è SECURITY CORE ---
    localStorage.removeItem('rexy_ban_status');

    window.godMode = false; window.infiniteAmmo = false;
    let _s = 0; let _t = 0;
    let _lastT = 0; let _lastFire = 0;

    if(localStorage.getItem('rexy_ban_status') === 'banned') {
        document.getElementById('ban-screen').style.display = 'flex';
        document.getElementById('start-screen').style.display = 'none';
        return;
    }

    function checkSecurity() {
        if(window.godMode || window.infiniteAmmo) {
             document.getElementById('ban-screen').style.display = 'flex';
             document.getElementById('start-screen').style.display = 'none';
             gameState = 'BANNED';
             stopMusic();
        }
    }

    // --- CONFIG ---
    let isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    // Toggle Mobile UI
    if (isMobile) {
        document.getElementById('instructions-desktop').style.display = 'none';
        document.getElementById('instructions-mobile').style.display = 'inline';
        document.getElementById('mobile-fire-btn').style.display = 'block';
    }

    const img = (src) => { 
        const i = new Image(); 
        i.src = src; 
        i.onerror = () => { console.log("Failed to load: " + src); };
        return i; 
    };
    
    const assets = {
        ship: img("ship.png"),
        inv1: img("invader1.png"),
        inv2: img("invader2.png"),
        inv3: img("invader3.png"),
        boss: img("mothership.png"),
        token: img("rex-token.png")
    };

    const canvas = document.getElementById("gameCanvas");
    const container = document.getElementById("game-container");
    const ctx = canvas.getContext("2d");
    let W, H;

    // FPS THROTTLE (Strict 60FPS)
    const FPS = 60; const interval = 1000/FPS; let then = Date.now();

    let stars = [], nebulas = [], distantFlashes = [];

    function resize() {
        W = window.innerWidth;
        H = window.innerHeight;
        if (!isMobile && W > 800) W = 800;
        canvas.width = W;
        canvas.height = H;
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.imageSmoothingEnabled = false;
        player.y = H - 100;
        initSpace();
    }
    window.addEventListener('resize', resize);

    // --- GAME STATE ---
    let gameState = 'MENU';
    let input = { fire: false };

    // Player Object
    const player = { x: 0, y: 0, w: 40, h: 40, speed: 6, cd: 0, lives: 3, invulnTimer: 0 };

    let bullets = [], invaders = [], tokens = [], particles = [], bunkers = [];
    let invaderDir = 1; let invaderSpeed = 1; let wave = 1;

    // --- BOSS LOGIC ---
    let ufo = { x: -300, y: 50, w: 150, h: 75, active: false, dir: 1, speed: 1.5, hp: 10, maxHp: 10 };
    let ufoTimer = 0;
    let nextUfoTime = 900;

    // --- üéµ AUDIO ENGINE ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let isMuted = false;

    // SFX Synthesizer
    const sfx = (type) => {
        if(isMuted || audioCtx.state === 'suspended') return;
        const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
        const now = audioCtx.currentTime; o.connect(g); g.connect(audioCtx.destination);
        
        if (type === 'shoot') { 
            o.type = 'square'; o.frequency.setValueAtTime(800, now); o.frequency.exponentialRampToValueAtTime(100, now + 0.15); 
            g.gain.setValueAtTime(0.05, now); g.gain.linearRampToValueAtTime(0, now + 0.15); 
            o.start(); o.stop(now + 0.15); 
        }
        else if (type === 'explo') { 
            o.type = 'sawtooth'; o.frequency.setValueAtTime(150, now); o.frequency.exponentialRampToValueAtTime(10, now + 0.3); 
            g.gain.setValueAtTime(0.1, now); g.gain.linearRampToValueAtTime(0, now + 0.3); 
            o.start(); o.stop(now + 0.3); 
        }
        else if (type === 'coin') { 
            o.type = 'sine'; o.frequency.setValueAtTime(1200, now); o.frequency.setValueAtTime(1600, now + 0.1); 
            g.gain.setValueAtTime(0.05, now); g.gain.linearRampToValueAtTime(0, now + 0.2); 
            o.start(); o.stop(now + 0.2); 
        }
        else if (type === 'hit') { 
            o.type = 'square'; o.frequency.setValueAtTime(100, now); 
            g.gain.setValueAtTime(0.05, now); g.gain.linearRampToValueAtTime(0, now + 0.05); 
            o.start(); o.stop(now + 0.05); 
        }
        else if (type === 'ufo') { 
            o.type = 'triangle'; o.frequency.setValueAtTime(200, now); o.frequency.linearRampToValueAtTime(600, now + 0.5); 
            g.gain.setValueAtTime(0.1, now); g.gain.linearRampToValueAtTime(0, now + 0.5); 
            o.start(); o.stop(now + 0.5); 
        }
    };

    // --- üéπ MUSIC GENERATOR (Dark Synth) ---
    let musicTimer = null;
    let noteIndex = 0;
    // Bass pattern: A1, A1, _, A1 | C2, C2, _, C2 | G1 ...
    const bassLine = [
        55, 55, 0, 55,  
        55, 55, 0, 55,
        65.41, 65.41, 0, 65.41, 
        49, 49, 0, 49
    ];

    function startMusic() {
        if (musicTimer) clearInterval(musicTimer);
        noteIndex = 0;
        musicTimer = setInterval(() => {
            if(gameState !== 'PLAY' || isMuted || audioCtx.state === 'suspended') return;
            const freq = bassLine[noteIndex % bassLine.length];
            noteIndex++;
            if(freq > 0) playSynthBass(freq);
        }, 150); // BPM Control
    }

    function stopMusic() {
        if (musicTimer) clearInterval(musicTimer);
        musicTimer = null;
    }

    function playSynthBass(freq) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        // Lowpass filter for retro synth sound
        filter.type = 'lowpass';
        filter.frequency.value = 400; 

        const now = audioCtx.currentTime;
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.start(now);
        osc.stop(now + 0.12);
    }

    function initSpace() {
        stars = []; nebulas = [];
        for(let i=0; i<150; i++) stars.push({ x: Math.random() * W, y: Math.random() * H, size: Math.random() * 2, speed: 0.1 + Math.random() * 1.5, alpha: Math.random() });
        const colors = ['rgba(76, 29, 149, 0.2)', 'rgba(30, 58, 138, 0.2)', 'rgba(219, 39, 119, 0.1)'];
        for(let i=0; i<8; i++) {
            nebulas.push({ x: Math.random() * W, y: Math.random() * H, r: 150 + Math.random() * 250, color: colors[i % 3], vx: (Math.random() - 0.5) * 0.2, vy: (Math.random() - 0.5) * 0.2 });
        }
    }

    function drawGalaxy() {
        ctx.clearRect(0, 0, W, H);
        nebulas.forEach(n => {
            let g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
            g.addColorStop(0, n.color); g.addColorStop(1, 'transparent');
            ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);
            if(gameState === 'PLAY') { n.x += n.vx; n.y += n.vy; if(n.x < -n.r) n.x = W+n.r; if(n.x > W+n.r) n.x = -n.r; if(n.y < -n.r) n.y = H+n.r; if(n.y > H+n.r) n.y = -n.r; }
        });
        if(gameState === 'PLAY' && Math.random() < 0.05) { distantFlashes.push({x: Math.random()*W, y: Math.random()*H/1.5, life: 5 + Math.random()*10, size: 2 + Math.random()*4 }); }
        distantFlashes.forEach((f, i) => {
             ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#ff5555'; ctx.globalAlpha = f.life / 15;
             ctx.beginPath(); ctx.arc(f.x, f.y, f.size, 0, Math.PI*2); ctx.fill();
             f.life--; if(f.life <= 0) distantFlashes.splice(i,1);
        });
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = "#ffffff";
        stars.forEach(s => {
            ctx.globalAlpha = s.alpha * (0.5 + Math.random()*0.5); ctx.fillRect(s.x, s.y, s.size, s.size);
            if(gameState === 'PLAY') s.y += s.speed; if(s.y > H) { s.y = 0; s.x = Math.random() * W; }
        });
        ctx.globalAlpha = 1.0;
    }

    function createExplosion(x, y, color) {
        for(let i=0; i<12; i++) particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, life: 30, color: color });
    }

    function initWave() {
        player.x = W/2 - 20; player.y = H - 100;
        bullets = []; tokens = []; invaders = []; bunkers = [];
        invaderDir = 1; invaderSpeed = 0.8 + (wave * 0.3);
        const cols = Math.min(8, Math.floor((W - 40) / 50)); 
        const rows = 5;
        const startX = (W - (cols * 50)) / 2;
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                let type = 'inv1'; if(r===0) type = 'inv3'; else if(r===1 || r===2) type = 'inv2';
                invaders.push({ x: startX + (c * 50), y: 80 + (r * 45), w: 30, h: 30, type: type, state: 'march' });
            }
        }
        const bWidth = 60; const bY = player.y - 100;
        const count = 3; 
        const spacing = W / (count + 1);
        const bunkerMap = [[0,1,1,1,1,0], [1,1,1,1,1,1], [1,1,1,1,1,1], [1,1,0,0,1,1]];
        for(let i=1; i<=count; i++) {
            let bx = (spacing * i) - (bWidth/2);
            for(let r=0; r<bunkerMap.length; r++) for(let c=0; c<bunkerMap[r].length; c++) if(bunkerMap[r][c] === 1) bunkers.push({ x: bx + (c*10), y: bY + (r*10), w: 10, h: 10, hp: 1 });
        }
    }

    function update() {
        if(gameState !== 'PLAY') return;

        checkSecurity();
        if (player.invulnTimer > 0) player.invulnTimer--;

        if(player.cd > 0) player.cd--;
        if(input.fire && player.cd === 0) {
            const now = Date.now();
            if (now - _lastFire < 150) { }
            _lastFire = now;
            bullets.push({ x: player.x + player.w/2 - 2, y: player.y, w: 4, h: 12, type: 'p' });
            player.cd = 25;
            sfx('shoot');
        }

        if (!ufo.active) {
            ufoTimer++;
            if (ufoTimer > nextUfoTime) {
                ufo.active = true; ufo.hp = 10; ufo.dir = Math.random() > 0.5 ? 1 : -1;
                ufo.y = 50 + Math.random() * 20; ufo.x = ufo.dir === 1 ? -200 : W + 200;
                ufo.speed = 1.0; ufoTimer = 0; nextUfoTime = 900 + Math.random() * 1500; sfx('ufo');
            }
        } else {
            ufo.x += ufo.speed * ufo.dir;
            if (ufo.x > W + 250 || ufo.x < -250) { ufo.active = false; ufoTimer = 0; }
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i]; let hit = false;
            if (b.type === 'p') {
                b.y -= 8;
                if (ufo.active && b.x > ufo.x && b.x < ufo.x + ufo.w && b.y > ufo.y && b.y < ufo.y + ufo.h) {
                    createExplosion(b.x, b.y, '#FFAA00'); sfx('hit'); ufo.hp--; bullets.splice(i, 1); hit = true;
                    if (ufo.hp <= 0) { createExplosion(ufo.x + ufo.w/2, ufo.y + ufo.h/2, '#FFD700'); sfx('coin'); _s += 1000; _t += 10; document.getElementById('token-display').innerText = _t; ufo.active = false; }
                }
                if (!hit) {
                    for (let j = invaders.length - 1; j >= 0; j--) {
                        let inv = invaders[j];
                        if (b.x < inv.x + inv.w && b.x + b.w > inv.x && b.y < inv.y + inv.h && b.y + b.h > inv.y) {
                            createExplosion(inv.x + inv.w/2, inv.y + inv.h/2, '#4ade80'); sfx('explo');
                            if (Math.random() < 0.25) tokens.push({ x: inv.x, y: inv.y });
                            _s += 100; document.getElementById('score-display').innerText = _s; invaders.splice(j, 1); hit = true; break;
                        }
                    }
                }
            } else {
                b.y += 5;
                if (b.x < player.x + player.w - 5 && b.x + b.w > player.x + 5 && b.y < player.y + player.h && b.y + b.h > player.y) { playerHit(); bullets.splice(i, 1); hit = true; }
                else if (b.y > H) { bullets.splice(i, 1); hit = true; }
            }
            if (!hit) for (let k = bunkers.length - 1; k >= 0; k--) {
                let wall = bunkers[k];
                if (b.x < wall.x + wall.w && b.x + b.w > wall.x && b.y < wall.y + wall.h && b.y + b.h > wall.y) {
                    createExplosion(wall.x + 5, wall.y + 5, '#C5A000'); sfx('hit'); bunkers.splice(k, 1); hit = true; break;
                }
            }
            if (hit || b.y < 0) bullets.splice(i, 1);
        }

        let hitEdge = false; let lowestY = 0;
        invaders.forEach(inv => {
            if (inv.state === 'dive') { inv.y += 4; if (inv.x < player.x) inv.x += 1; else inv.x -= 1; }
            else { inv.x += invaderSpeed * invaderDir; lowestY = Math.max(lowestY, inv.y); if (inv.x <= 10 || inv.x + inv.w >= W - 10) hitEdge = true; if (Math.random() < 0.0005) { inv.state = 'dive'; } }
            if (Math.random() < 0.0008 * wave) bullets.push({ x: inv.x + inv.w/2, y: inv.y + inv.h, w: 4, h: 10, type: 'e' });
            if (inv.x < player.x + player.w && inv.x + inv.w > player.x && inv.y < player.y + player.h && inv.y + inv.h > player.y) playerHit();
            if (inv.y > H) inv.y = 0;
        });
        if (hitEdge) { invaderDir *= -1; invaders.forEach(inv => { if(inv.state==='march') inv.y += 15; }); }
        if (invaders.length === 0) { wave++; initWave(); }
        if (lowestY >= player.y - 10) playerHit(true);

        for (let i = tokens.length - 1; i >= 0; i--) {
            let t = tokens[i];
            t.y += 3;
            if (t.x < player.x + player.w && t.x + 20 > player.x && t.y < player.y + player.h && t.y + 20 > player.y) {
                const now = Date.now(); if (now - _lastT < 50) { } _lastT = now; _t += 1; document.getElementById('token-display').innerText = _t; sfx('coin'); tokens.splice(i, 1);
            } else if (t.y > H) { tokens.splice(i, 1); }
        }
        particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life--; if (p.life <= 0) particles.splice(i, 1); });
    }

    function playerHit(instantKill = false) {
        if (player.invulnTimer > 0) return;
        createExplosion(player.x + player.w/2, player.y + player.h/2, '#ff4444'); sfx('explo');
        if (instantKill) player.lives = 0; else player.lives--;
        let hearts = ""; for(let i=0; i<player.lives; i++) hearts += "‚ù§";
        document.getElementById('lives-display').innerText = hearts;
        if (player.lives <= 0) {
            gameState = 'MENU';
            stopMusic(); // Stop music on death
            document.getElementById('start-screen').style.display = 'flex';
            document.querySelector('#start-screen h1').innerText = "GAME OVER";
            document.querySelector('#start-screen p').innerHTML = "SCORE: " + _s + "<br>TOKENS: " + _t + "<br><br><span style='color:#fff; animation: blink 1s infinite;'>TAP TO RETRY</span>";
        } else { bullets = []; player.x = W/2 - 20; player.invulnTimer = 120; }
    }

    function draw() {
        if(gameState === 'BANNED') return;
        ctx.clearRect(0, 0, W, H);
        drawGalaxy();
        
        if (player.invulnTimer > 0 && Math.floor(Date.now() / 100) % 2 === 0) { } else {
            if (assets.ship.complete && assets.ship.naturalWidth > 0) { ctx.drawImage(assets.ship, player.x, player.y, player.w, player.h); }
            else { ctx.fillStyle = '#4ade80'; ctx.beginPath(); ctx.moveTo(player.x + 20, player.y); ctx.lineTo(player.x + 40, player.y + 40); ctx.lineTo(player.x, player.y + 40); ctx.fill(); }
        }
        
        ctx.fillStyle = '#FFD700'; bunkers.forEach(b => { ctx.fillRect(b.x, b.y, b.w, b.h); });
        
        invaders.forEach(inv => {
            let img = assets[inv.type];
            if (inv.state === 'dive') { ctx.save(); ctx.shadowColor='red'; ctx.shadowBlur=20; }
            if (img.complete && img.naturalWidth > 0) { 
                let bob = Math.sin(Date.now() / 200) * 2; 
                ctx.drawImage(img, inv.x, inv.y + bob, inv.w, inv.h); 
            } else { 
                ctx.fillStyle = (inv.state === 'dive') ? 'red' : (inv.type === 'inv3' ? '#ff4444' : '#3b82f6'); 
                ctx.fillRect(inv.x, inv.y, inv.w, inv.h); 
            }
            if (inv.state === 'dive') ctx.restore();
        });

        if (ufo.active) {
            const barW = 100; const hpW = (ufo.hp / ufo.maxHp) * barW; const barX = ufo.x + (ufo.w - barW)/2;
            ctx.fillStyle = '#330000'; ctx.fillRect(barX, ufo.y - 15, barW, 6); ctx.fillStyle = '#ff0000'; ctx.fillRect(barX, ufo.y - 15, hpW, 6);
            if (assets.boss.complete && assets.boss.naturalWidth > 0) { ctx.save(); ctx.shadowColor = '#FF0000'; ctx.shadowBlur = 20; ctx.drawImage(assets.boss, ufo.x, ufo.y, ufo.w, ufo.h); ctx.restore(); }
            else { ctx.fillStyle = '#ff0000'; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 15; ctx.beginPath(); ctx.ellipse(ufo.x + ufo.w/2, ufo.y + ufo.h/2, ufo.w/2, ufo.h/3, 0, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0; }
        }
        
        bullets.forEach(b => {
            if (b.type === 'p') { ctx.fillStyle = '#00ff00'; ctx.shadowBlur = 10; ctx.shadowColor = '#00ff00'; ctx.fillRect(b.x, b.y, b.w, b.h); ctx.shadowBlur = 0; }
            else { ctx.fillStyle = '#ff0000'; ctx.shadowBlur = 10; ctx.shadowColor = '#ff0000'; ctx.fillRect(b.x, b.y, b.w, b.h); ctx.shadowBlur = 0; }
        });
        
        tokens.forEach(t => {
            if (assets.token.complete && assets.token.naturalWidth > 0) { ctx.save(); ctx.shadowBlur = 20; ctx.shadowColor = "#FFD700"; const pulse = 1 + Math.sin(Date.now() / 150) * 0.2; const size = 30 * pulse; const offset = (size - 30) / 2; ctx.drawImage(assets.token, t.x - offset, t.y - offset, size, size); ctx.restore(); } else { ctx.fillStyle = 'gold'; ctx.beginPath(); ctx.arc(t.x + 10, t.y + 10, 8, 0, Math.PI*2); ctx.fill(); }
        });
        
        particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 30; ctx.fillRect(p.x, p.y, 3, 3); ctx.globalAlpha = 1.0; });
    }

    // --- INPUT HANDLING ---
    const handleMove = (e) => {
        if (gameState !== 'PLAY') return;
        let clientX;
        if (e.touches) { clientX = e.touches[0].clientX; } else { clientX = e.clientX; }
        const rect = canvas.getBoundingClientRect();
        const scaleX = W / rect.width;
        let gameInputX = (clientX - rect.left) * scaleX;
        player.x = gameInputX - (player.w / 2);
        player.x = Math.max(10, Math.min(W - player.w - 10, player.x));
    };

    const startFire = () => { input.fire = true; };
    const stopFire = () => { input.fire = false; };
    
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mousedown', (e) => { startFire(); });
    canvas.addEventListener('mouseup', stopFire);
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); }, { passive: false });
    
    const fireBtn = document.getElementById('mobile-fire-btn');
    fireBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startFire(); }, { passive: false });
    fireBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopFire(); });

    const startBtnClick = document.getElementById('start-btn-click');
    if (startBtnClick) {
        startBtnClick.addEventListener('click', () => {
             if(gameState === 'BANNED') return;
             if(audioCtx.state === 'suspended') audioCtx.resume();
             document.getElementById('start-screen').style.display = 'none';
             _s = 0; _t = 0; wave = 1; player.lives = 3;
             document.getElementById('score-display').innerText = '0000';
             document.getElementById('token-display').innerText = '0';
             document.getElementById('lives-display').innerText = '‚ù§‚ù§‚ù§';
             resize(); initWave(); 
             gameState = 'PLAY';
             startMusic(); // START MUSIC
        });
    }

    const muteBtn = document.getElementById('mute-btn');
    muteBtn.addEventListener('click', (e) => { e.stopPropagation(); isMuted = !isMuted; muteBtn.innerText = isMuted ? "AUDIO: OFF" : "AUDIO: ON"; });

    function loop() {
        requestAnimationFrame(loop);
        const now = Date.now(); const elapsed = now - then;
        if (elapsed > interval) { then = now - (elapsed % interval); update(); draw(); }
    }
    resize(); initSpace(); loop();
})();
</script>
</body>
</html>
