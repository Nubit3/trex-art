<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Rexy Runner: Ultimate</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; background-color: #000;
      font-family: 'Press Start 2P', cursive;
      user-select: none; -webkit-user-select: none; touch-action: none;
    }
    #game-container {
      position: relative; width: 100%; height: 100%;
      display: flex; justify-content: center; align-items: center;
      background: #000;
    }
    canvas {
      display: block; width: 100%; height: 100%;
      image-rendering: pixelated;
    }
    #scanlines {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(to bottom, rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%);
      background-size: 100% 4px; pointer-events: none; z-index: 5; opacity: 0.3;
    }
    .overlay-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        display: none; flex-direction: column; justify-content: center; align-items: center;
        text-align: center; z-index: 20; backdrop-filter: blur(4px);
    }
    #pause-screen { background: rgba(0,0,0,0.7); color: white; }
    #pause-text { font-size: 24px; line-height: 2; text-shadow: 4px 4px 0 #000; }
    #ban-screen { background: rgba(50, 0, 0, 0.95); color: #ff5555; border: 4px solid red; box-sizing: border-box; }
    #ban-text { font-size: 18px; line-height: 1.5; padding: 20px; }
  </style>
</head>
<body>

<div id="game-container">
    <div id="scanlines"></div>
    <div id="pause-screen" class="overlay-screen">
        <div id="pause-text">PAUSED<br><span style="font-size: 0.5em; color: #aaa;">TAP TO RESUME</span></div>
    </div>
    <div id="ban-screen" class="overlay-screen">
        <div id="ban-text"><h1 style="color:red; margin-bottom:20px;">SYSTEM LOCKDOWN</h1>SUSPICIOUS ACTIVITY.<br>ACCESS DENIED.</div>
    </div>
    <canvas id="rexyCanvas"></canvas>
</div>

<script>
  // --- 0. DYNAMIC VARIABLES ---
  const canvas = document.getElementById("rexyCanvas");
  const ctx = canvas.getContext("2d");
  
  let W = window.innerWidth;
  let H = window.innerHeight;
  let GROUND_Y = H - 100; 
  let SCALE = 1;

  // --- 1. RESIZE ENGINE ---
  function resize() {
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width = W;
      canvas.height = H;
      if (H > W) { 
          // MOBILE
          GROUND_Y = H - 180; 
          SCALE = 0.9; 
      } else { 
          // DESKTOP
          GROUND_Y = H - 100;
          SCALE = 1.0;
      }
      ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', resize);
  resize();

  // --- 2. ASSETS ---
  const assets = {
    rexyRun:   { src: "rexy-run-sheet.png", img: new Image() },
    rexyJump:  { src: "rexy-jump.png",      img: new Image() },
    rexToken:  { src: "rex-token.png",      img: new Image() },
    elon:      { src: "elon.png",     img: new Image() },
    trump:     { src: "trump.png",    img: new Image() },
    cz:        { src: "cz.png",       img: new Image() },
    vitalik:   { src: "vitalik.png",  img: new Image() },
    rocket:    { src: "rocket.png",     img: new Image() },
    whale:     { src: "whale.png",      img: new Image() },
    cloud:     { src: "cloud.png",      img: new Image() }, // Enemy Cloud
    hammer:    { src: "hammer.png",     img: new Image() },
    satellite: { src: "satellite.png",  img: new Image() },
    astronaut: { src: "astronaut.png",  img: new Image() },
    obstacles: [
      { src: "wallet.png",       img: new Image(), w: 84, h: 72, type: 'ground' },
      { src: "green-candle.png", img: new Image(), w: 48, h: 96, type: 'ground' },
      { src: "bitcoin.png",      img: new Image(), w: 80, h: 80, type: 'ground' },
      { src: "gas-pump.png",     img: new Image(), w: 92, h: 92, type: 'ground' },
      { src: "red-candle.png",   img: new Image(), w: 48, h: 96, type: 'ground' }
    ]
  };

  // --- 3. BIOMES ---
  const biomes = [
    { sky: [135, 206, 235], horizon: [210, 180, 140], ground: [244, 164, 96], detail: [199, 140, 83], line: [139, 69, 19], text: [51, 51, 51], starAlpha: 0.0 }, // Desert
    { sky: [10, 10, 42],    horizon: [0, 51, 0],      ground: [0, 77, 0],      detail: [0, 102, 0],    line: [0, 255, 0],    text: [255, 255, 255], starAlpha: 0.6 }, // Neon Night
    { sky: [224, 247, 250], horizon: [178, 235, 242], ground: [255, 255, 255], detail: [167, 198, 207], line: [0, 172, 193],  text: [51, 51, 51],    starAlpha: 0.0 }, // Ice
    { sky: [34, 10, 10],    horizon: [51, 0, 0],      ground: [26, 26, 26],    detail: [68, 17, 17],    line: [255, 51, 0],    text: [255, 255, 255], starAlpha: 0.6 }  // Mars
  ];
  let activePalette = JSON.parse(JSON.stringify(biomes[0]));

  function lerp(start, end, amt) { return (1 - amt) * start + amt * end; }
  function lerpColorArr(current, target) {
      const speed = 0.02;
      current[0] = lerp(current[0], target[0], speed); 
      current[1] = lerp(current[1], target[1], speed); 
      current[2] = lerp(current[2], target[2], speed);
      return `rgb(${Math.round(current[0])}, ${Math.round(current[1])}, ${Math.round(current[2])})`;
  }

  function updateBiomeAndColors() {
      const phase = Math.floor(distance / 250) % biomes.length;
      const target = biomes[phase];
      const bgString = lerpColorArr(activePalette.sky, target.sky);
      const groundString = lerpColorArr(activePalette.ground, target.ground);
      const horizonString = lerpColorArr(activePalette.horizon, target.horizon);
      const detailString = lerpColorArr(activePalette.detail, target.detail);
      const lineString = lerpColorArr(activePalette.line, target.line);
      const textString = lerpColorArr(activePalette.text, target.text);
      activePalette.starAlpha = lerp(activePalette.starAlpha, target.starAlpha, 0.02);
      return { bgString, groundString, horizonString, detailString, lineString, textString };
  }

  // --- 4. AUDIO ---
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sfx = {
    playTone: (freq, type, duration) => {
      if(audioCtx.state === 'suspended') audioCtx.resume();
      const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
      osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      gain.gain.setValueAtTime(0.05, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
      osc.connect(gain); gain.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + duration);
    },
    jump: () => sfx.playTone(150, 'square', 0.1), coin: () => sfx.playTone(1200, 'sine', 0.1),
    crash: () => sfx.playTone(100, 'sawtooth', 0.5), hurt: () => { sfx.playTone(80, 'sawtooth', 0.2); },
    heal: () => { sfx.playTone(500, 'sine', 0.1); }, go: () => { sfx.playTone(880, 'square', 0.1); },
    tick: () => sfx.playTone(440, 'square', 0.1), powerup: () => { sfx.playTone(400, 'square', 0.1); }
  };

  // --- 5. GAME LOOP ---
  function startLoading() {
      Object.values(assets).forEach(val => { if(val.src) val.img.src = val.src; else if(Array.isArray(val)) val.forEach(obs => obs.img.src = obs.src); });
      initEnvironment(); requestAnimationFrame(animate);
  }

  let gameStarted = false, isGameOver = false, isPaused = false, isCountingDown = false;
  let countdownNum = 5, countdownTimer = 0, distance = 0, rexCount = 0, lives = 5;
  let lastDamageFrame = -1000, activeMultiplier = 1, multiplierTimer = 0, heroPassCount = 0;
  const HEROES_TO_HEAL = 2; // +1 Life every 2 heroes
  let speed = 4; 
  let obstacles = [], tokens = [], frame = 0, nextObstacleFrame = 0, nextTokenFrame = 0;
  let stars = [], clouds = [], horizonShapes = [], groundDetails = [];

  const rexy = {
    x: 50, y: 0, w: 88, h: 88, vy: 0, isJumping: false, isDucking: false,
    update() {
      if (this.isDucking && !this.isJumping) { 
          this.h = 50 * SCALE; 
          this.y = GROUND_Y - this.h; 
      } else {
          this.h = 88 * SCALE;
          this.y += this.vy;
          if (this.y < GROUND_Y - this.h) { this.vy += 0.9; this.isJumping = true; } 
          else { this.y = GROUND_Y - this.h; this.vy = 0; this.isJumping = false; }
      }
    },
    draw() {
      if (frame - lastDamageFrame < 120 && Math.floor(frame/10)%2===0) return;
      let sprite = assets.rexyRun.img;
      if (this.isJumping) sprite = assets.rexyJump.img;
      let drawW = this.w; let drawH = this.h;
      if (sprite.complete && sprite.naturalWidth > 0) {
         if(this.isDucking) {
             const frameW = sprite.naturalWidth / 2;
             ctx.drawImage(sprite, 0, 0, frameW, sprite.naturalHeight, this.x, this.y, drawW, 50 * SCALE);
         } else if (this.isJumping) {
             ctx.drawImage(sprite, this.x, this.y, drawW, drawH);
         } else {
             const frameW = sprite.naturalWidth / 2;
             const animSpeed = Math.max(10, Math.floor(60 / (speed * 0.5)));
             const currentFrame = (isCountingDown) ? 0 : Math.floor(frame / animSpeed) % 2;
             ctx.drawImage(sprite, currentFrame * frameW, 0, frameW, sprite.naturalHeight, this.x, this.y, drawW, drawH);
         }
      } else { ctx.fillStyle = "#34d399"; ctx.fillRect(this.x, this.y, drawW, drawH); }
    }
  };

  function initEnvironment() {
    stars=[]; clouds=[]; horizonShapes=[]; groundDetails=[];
    for(let i=0; i<60; i++) stars.push({ x: Math.random()*W, y: Math.random()*(H-160), size: Math.random()*3, speed: Math.random()*0.2+0.1 });
    // SCENERY CLOUDS (Procedural)
    for(let i=0; i<12; i++) clouds.push({ x: Math.random()*W, y: Math.random()*(H/2), w: 80+Math.random()*80, h: 30+Math.random()*20, speed: Math.random()*0.3+0.2 });
    for(let i=0; i<20; i++) horizonShapes.push({ x: i*150, w: 120+Math.random()*60, h: 50+Math.random()*50 });
    for(let i=0; i<40; i++) groundDetails.push({ x: Math.random()*W, y: H, size: Math.random()*5+2, offset: Math.random()*100 });
  }

  function spawnObstacle() {
    const spawnX = W + 100;
    const r = Math.random();
    const obsScale = SCALE;
    
    // 1. HEROES
    if (r > 0.90) { 
        const heroRoll = Math.random();
        let img = assets.vitalik.img; let mult = 2;
        if (heroRoll > 0.85) { img = assets.elon.img; mult=5; } else if (heroRoll > 0.60) { img = assets.trump.img; mult=4; } else if (heroRoll > 0.35) { img = assets.cz.img; mult=3; }
        obstacles.push({ x: spawnX, y: GROUND_Y - (88*obsScale), w: 80*obsScale, h: 88*obsScale, img: img, type: 'hero', multiplier: mult, passed: false });
        return;
    }
    
    // 2. FLYING (Includes Enemy Cloud)
    if (r > 0.65) { 
        let skyImg = assets.rocket.img; let movement = 'sine'; 
        const skyRoll = Math.random();
        if (skyRoll < 0.16) { skyImg = assets.rocket.img; movement = 'sine'; }
        else if (skyRoll < 0.32) { skyImg = assets.whale.img; movement = 'slow_sine'; }
        else if (skyRoll < 0.48) { skyImg = assets.cloud.img; movement = 'jitter'; } // <-- Enemy Cloud is here
        else if (skyRoll < 0.64) { skyImg = assets.hammer.img; movement = 'aggressive'; }
        else if (skyRoll < 0.80) { skyImg = assets.satellite.img; movement = 'smooth'; }
        else { skyImg = assets.astronaut.img; movement = 'drift'; }
        
        let yPos = GROUND_Y - (150 + Math.random()*100); 
        obstacles.push({ x: spawnX, y: yPos, w: 120*obsScale, h: 72*obsScale, img: skyImg, type: 'flying', movementType: movement, baseY: yPos, hoverOffset: Math.random() * 100 });
        return;
    }
    
    // 3. GROUND
    let idx = Math.floor(Math.random() * assets.obstacles.length);
    const template = assets.obstacles[idx];
    obstacles.push({ x: spawnX, y: GROUND_Y - (template.h*obsScale), w: template.w*obsScale, h: template.h*obsScale, img: template.img, type: 'ground' });
  }

  function spawnToken() {
    const spawnX = W + 100;
    const safetyDistance = 400;
    const isUnsafe = obstacles.some(obs => obs.x > W - safetyDistance);
    if (isUnsafe) { nextTokenFrame += 20; return; }
    const heightVar = Math.random() > 0.5 ? 80 : 160;
    tokens.push({ x: spawnX, y: GROUND_Y - heightVar, w: 68*SCALE, h: 68*SCALE, collected: false });
  }

  function animate() {
    if (isPaused) { requestAnimationFrame(animate); return; }
    
    const colors = updateBiomeAndColors();

    // Background
    ctx.fillStyle = colors.bgString;
    ctx.fillRect(0, 0, W, H);
    
    // Environment - STARS & SCENERY CLOUDS
    if (activePalette.starAlpha > 0.01) {
        ctx.fillStyle = `rgba(255, 255, 255, ${activePalette.starAlpha})`;
        stars.forEach(s => { ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.size, s.size); if(gameStarted && !isGameOver) s.x -= s.speed; if(s.x < 0) s.x = W; });
    }
    
    // FIXED: Background clouds are now 8-BIT SHAPES (Not the asset)
    if (activePalette.starAlpha < 0.5) {
        ctx.fillStyle = `rgba(255, 255, 255, ${0.6 - activePalette.starAlpha})`;
        clouds.forEach(c => { 
            // Simple retro cloud shape (2 rectangles)
            ctx.fillRect(Math.floor(c.x), Math.floor(c.y), c.w, c.h); 
            ctx.fillRect(Math.floor(c.x + c.w*0.2), Math.floor(c.y - c.h*0.5), c.w*0.6, c.h);
            if(gameStarted && !isGameOver) c.x -= c.speed; if(c.x + c.w < 0) c.x = W; 
        });
    }

    // Ground & Horizon
    ctx.fillStyle = colors.groundString;
    ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
    ctx.strokeStyle = colors.lineString;
    ctx.lineWidth = 5; 
    ctx.beginPath(); ctx.moveTo(0, GROUND_Y); ctx.lineTo(W, GROUND_Y); ctx.stroke();
    ctx.fillStyle = colors.horizonString;
    horizonShapes.forEach(h => { 
        ctx.beginPath(); ctx.moveTo(h.x, GROUND_Y); ctx.lineTo(h.x + h.w/2, GROUND_Y - h.h); ctx.lineTo(h.x + h.w, GROUND_Y); ctx.fill(); 
        if(gameStarted && !isGameOver) h.x -= speed * 0.5; if(h.x + h.w < 0) h.x = W; 
    });
    ctx.fillStyle = colors.detailString;
    groundDetails.forEach(d => { 
        ctx.fillRect(Math.floor(d.x), Math.floor(d.y), d.size, d.size); 
        if(gameStarted && !isGameOver) d.x -= speed; if(d.x < 0) d.x = W; 
    });

    if (isCountingDown) {
        rexy.draw();
        ctx.fillStyle = "#FFD700"; ctx.textAlign = "center"; ctx.font = "bold 60px 'Press Start 2P'";
        ctx.fillText(countdownNum > 0 ? countdownNum : "GO!", W/2, H/2);
        if (performance.now() - countdownTimer > 1000) { countdownNum--; countdownTimer = performance.now(); if(countdownNum<0) { isCountingDown=false; gameStarted=true; } }
        requestAnimationFrame(animate); return;
    }

    if (!gameStarted) {
        ctx.fillStyle = "#34d399"; ctx.textAlign = "center"; ctx.font = "30px 'Press Start 2P'";
        ctx.fillText("REXY RUNNER", W/2, H/2 - 40);
        ctx.font = "16px 'Press Start 2P'"; ctx.fillStyle = colors.textString;
        ctx.fillText("TAP OR SPACE TO START", W/2, H/2 + 20);
        rexy.y = GROUND_Y - rexy.h; rexy.draw();
        requestAnimationFrame(animate); return;
    }

    rexy.update(); rexy.draw();

    if (frame >= nextObstacleFrame) { spawnObstacle(); nextObstacleFrame = frame + Math.floor(300/speed) + Math.random()*100; }
    if (frame >= nextTokenFrame) { spawnToken(); nextTokenFrame = frame + 80 + Math.random()*150; }

    obstacles = obstacles.filter(obs => obs.x + obs.w > -200);
    obstacles.forEach((obs, index) => {
        obs.x -= speed;
        let drawY = obs.y;
        if(obs.type === 'flying') {
            const t = (frame + obs.hoverOffset) * 0.05;
            if (obs.movementType === 'sine') drawY = obs.baseY + Math.sin(t) * 20;
            else if (obs.movementType === 'jitter') drawY = obs.baseY + (Math.random() * 8 - 4);
            else drawY = obs.baseY + Math.sin(t) * 10;
        }

        if(obs.img && obs.img.complete && obs.img.naturalWidth > 0) {
            ctx.drawImage(obs.img, obs.x, drawY, obs.w, obs.h);
        } else { 
            ctx.fillStyle = (obs.type === 'hero') ? '#4ade80' : '#f87171'; 
            ctx.fillRect(obs.x, drawY, obs.w, obs.h); 
        }

        if (rexy.x < obs.x + obs.w - 20 && rexy.x + rexy.w > obs.x + 20 && rexy.y < obs.y + obs.h - 10 && rexy.y + rexy.h > obs.y + 10) {
             if (obs.type === 'hero' && !obs.passed) { /* pass */ } 
             else if (frame - lastDamageFrame > 120) { lives--; sfx.hurt(); lastDamageFrame = frame; if(lives<=0) { isGameOver=true; sfx.crash(); } }
        }

        // HERO PASS LOGIC (RESTORED & FIXED)
        if (obs.type === 'hero' && !obs.passed && obs.x + obs.w < rexy.x) {
            obs.passed = true; 
            activeMultiplier = obs.multiplier; 
            multiplierTimer = frame + 600;
            
            heroPassCount++;
            // Heal if 2 heroes passed
            if (heroPassCount >= HEROES_TO_HEAL) {
                heroPassCount = 0;
                if(lives < 5) { lives++; sfx.heal(); } else { sfx.powerup(); }
            } else {
                sfx.powerup();
            }
        }
    });

    tokens = tokens.filter(t => t.x + t.w > -200 && !t.collected);
    tokens.forEach(t => {
        t.x -= speed;
        const pulse = Math.sin(frame * 0.2) * 5; 
        if(assets.rexToken.img.complete && assets.rexToken.img.naturalWidth > 0) {
            ctx.drawImage(assets.rexToken.img, t.x - pulse/2, t.y - pulse/2, t.w + pulse, t.h + pulse);
        } else { 
            ctx.fillStyle="gold"; ctx.beginPath(); ctx.arc(t.x + t.w/2, t.y + t.h/2, (t.w/2) + pulse, 0, Math.PI*2); ctx.fill(); 
        }
        if (rexy.x < t.x + t.w && rexy.x + rexy.w > t.x && rexy.y < t.y + t.h && rexy.y + rexy.h > t.y) {
            t.collected = true; rexCount += 1; sfx.coin();
        }
    });

    ctx.fillStyle = "#ff4444"; ctx.font = "16px 'Press Start 2P'"; ctx.textAlign = "left";
    let hearts = ""; for(let i=0; i<lives; i++) hearts += "â¤"; ctx.fillText(hearts, 20, 40);
    
    ctx.textAlign = "right"; ctx.fillStyle = "#FFD700";
    ctx.fillText("$REX: " + rexCount, W - 20, 40);
    ctx.fillStyle = colors.textString;
    ctx.fillText(Math.floor(distance) + "m", W - 20, 70);

    if (!isGameOver) { distance += 0.1; frame++; if (speed < 15) speed += 0.001; requestAnimationFrame(animate); }
    else {
        ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(0,0,W,H);
        ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.font = "30px 'Press Start 2P'";
        ctx.fillText("GAME OVER", W/2, H/2 - 20);
        ctx.font = "16px 'Press Start 2P'";
        ctx.fillText("TAP TO RESTART", W/2, H/2 + 40);
    }
  }

  function handleInput() {
      if(!gameStarted && !isCountingDown) { if(audioCtx.state === 'suspended') audioCtx.resume(); startCountdown(); return; }
      if(isGameOver) { isGameOver=false; obstacles=[]; tokens=[]; distance=0; rexCount=0; lives=5; speed=4; startCountdown(); return; }
      if(!rexy.isJumping) { rexy.vy = -18 * SCALE; sfx.jump(); }
  }
  function startCountdown() { isCountingDown=true; countdownNum=3; countdownTimer=performance.now(); requestAnimationFrame(animate); }
  
  window.addEventListener("keydown", (e) => { if(e.code==="Space" || e.code==="ArrowUp") handleInput(); });
  document.getElementById("game-container").addEventListener("touchstart", (e) => { e.preventDefault(); handleInput(); }, {passive:false});
  document.getElementById("game-container").addEventListener("mousedown", (e) => { e.preventDefault(); handleInput(); });

  startLoading();
</script>
</body>
</html>
